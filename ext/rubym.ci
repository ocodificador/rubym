function  :gtm_char_t* function^v4wNode(I:gtm_char_t*, I:gtm_char_t*, I:gtm_uint_t)
get       :gtm_char_t* get^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
global_directory :gtm_char_t* globalDirectory^v4wNode(I:gtm_uint_t, I:gtm_char_t*, I:gtm_char_t*)
increment :gtm_char_t* increment^v4wNode(I:gtm_char_t*, I:gtm_char_t*, I:gtm_double_t)
lock      :gtm_char_t* lock^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
merge     :gtm_char_t* merge^v4wNode(I:gtm_char_t*, I:gtm_char_t*, I:gtm_char_t*, I:gtm_char_t*)
next_node :gtm_char_t* nextNode^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
order     :gtm_char_t* order^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
previous  :gtm_char_t* previous^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
previous_node :gtm_char_t* previousNode^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
retrieve  :gtm_char_t* retrieve^v4wNode()
set       :gtm_char_t* set^v4wNode(I:gtm_char_t*, I:gtm_char_t*, I:gtm_char_t*)
unlock    :gtm_char_t* unlock^v4wNode(I:gtm_char_t*, I:gtm_char_t*)
update    :gtm_char_t* update^v4wNode()

test1     :void t1^ruby( O:gtm_char_t* )

gtmget    : void get^%gtmaccess( I:gtm_char_t*, O:gtm_string_t*, O:gtm_char_t* )
gtminit   : void init^%gtmaccess( O:gtm_char_t* )
gtmlock   : void lock^%gtmaccess( I:gtm_char_t*, O:gtm_char_t* )
gtmorder  : void order^%gtmaccess( I:gtm_char_t*, O:gtm_string_t*, O:gtm_char_t* )
gtmquery  : void query^%gtmaccess( I:gtm_char_t*, O:gtm_string_t*, O:gtm_char_t* )
gtmset    : void set^%gtmaccess( I:gtm_char_t*, I:gtm_string_t*, O:gtm_char_t*)
gtmxecute : void xecute^%gtmaccess( I:gtm_char_t*, O:gtm_char_t* )

data		: void	data^ruby( I:gtm_char_t*, I:gtm_char_t*, O:gtm_char_t*, O:gtm_char_t* )
get		: void	get^ruby( I:gtm_char_t*, I:gtm_char_t*, O:gtm_char_t*, O:gtm_char_t* )
init		: void	init^ruby( O:gtm_char_t* )
kill		: void	kill^ruby( I:gtm_char_t*, I:gtm_char_t*, O:gtm_char_t*, O:gtm_char_t* )
version		: void	version^ruby( O:gtm_char_t*, O:gtm_char_t* )
